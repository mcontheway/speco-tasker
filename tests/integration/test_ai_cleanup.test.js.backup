// SCOPE: AI内容清理真实集成测试，使用实际CLI命令验证AI内容的检测、清理和验证的完整工作流
const path = require("path");
const fs = require("fs");
const { execSync, spawn } = require("child_process");

describe("AI Content Cleanup Realistic Integration Tests", () => {
	const testProjectDir = path.join(
		__dirname,
		"..",
		"..",
		"tmp",
		"ai-cleanup-realistic-test",
	);
	const specoDir = path.join(testProjectDir, ".speco");

	beforeAll(async () => {
		// Create test project structure with realistic AI content
		if (fs.existsSync(testProjectDir)) {
			fs.rmSync(testProjectDir, { recursive: true, force: true });
		}
		fs.mkdirSync(testProjectDir, { recursive: true });
		fs.mkdirSync(specoDir, { recursive: true });

		// Initialize git repository
		execSync("git init", { cwd: testProjectDir, stdio: "pipe" });

		// Create test files with AI content (模拟真实项目状态)
		createTestFilesWithAIContent();
	});

	afterAll(async () => {
		// Cleanup test directory
		if (fs.existsSync(testProjectDir)) {
			fs.rmSync(testProjectDir, { recursive: true, force: true });
		}
	});

	function createTestFilesWithAIContent() {
		const testFiles = {
			"src/ai-client.js": `// AI-powered client for task management
const OpenAI = require('openai');
const Claude = require('@anthropic-ai/sdk');

class AIClient {
  constructor() {
    this.openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY
    });

    this.claude = new Claude({
      apiKey: process.env.ANTHROPIC_API_KEY
    });
  }

  async getTaskSuggestions(tasks) {
    const response = await this.openai.chat.completions.create({
      model: "gpt-4",
      messages: [{
        role: "system",
        content: "You are an AI task management assistant."
      }]
    });
    return response.choices[0].message.content;
  }
}

module.exports = AIClient;`,

			"src/chatgpt-integration.js": `// ChatGPT integration for enhanced task analysis
const { Configuration, OpenAIApi } = require("openai");

const configuration = new Configuration({
  apiKey: process.env.OPENAI_API_KEY,
});

const openai = new OpenAIApi(configuration);

async function analyzeTaskWithChatGPT(task) {
  const response = await openai.createCompletion({
    model: "text-davinci-003",
    prompt: \`Analyze this task: \${task.description}\`,
    max_tokens: 150
  });

  return response.data.choices[0].text.trim();
}

module.exports = { analyzeTaskWithChatGPT };`,

			"docs/ai-setup.md": `# AI Integration Setup

This project uses several AI services for enhanced functionality:

## Supported AI Providers

- **OpenAI GPT-4**: For task analysis and suggestions
- **Anthropic Claude**: For complex reasoning tasks
- **ChatGPT API**: For conversational interfaces

## Configuration

Set the following environment variables:

\`\`\`bash
export OPENAI_API_KEY="your-openai-key"
export ANTHROPIC_API_KEY="your-anthropic-key"
\`\`\`

## Usage Examples

\`\`\`javascript
const aiClient = new AIClient();
const suggestions = await aiClient.getTaskSuggestions(tasks);
\`\`\`
`,

			"src/utils/claude-helper.js": `// Claude AI helper utilities
const Anthropic = require('@anthropic-ai/sdk');

const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY,
});

async function getClaudeAnalysis(text) {
  const response = await anthropic.messages.create({
    model: 'claude-3-sonnet-20240229',
    max_tokens: 1000,
    messages: [{
      role: 'user',
      content: \`Analyze this text: \${text}\`
    }]
  });

  return response.content[0].text;
}

module.exports = { getClaudeAnalysis };`,

			".speco/config.json": JSON.stringify(
				{
					project: {
						name: "speco-tasker",
						version: "1.2.0",
					},
					features: {
						aiCleanup: true,
						brandRebrand: true,
						pathConfig: true,
					},
				},
				null,
				2,
			),
		};

		// Write all test files
		for (const [filePath, content] of Object.entries(testFiles)) {
			const fullPath = path.join(testProjectDir, filePath);
			const dir = path.dirname(fullPath);
			if (!fs.existsSync(dir)) {
				fs.mkdirSync(dir, { recursive: true });
			}
			fs.writeFileSync(fullPath, content, "utf8");
		}
	}

	/**
	 * 执行真实的CLI命令（当命令实现后使用）
	 * @param {string} command - CLI命令
	 * @param {string[]} args - 命令参数
	 * @returns {Promise<{stdout: string, stderr: string, code: number}>}
	 */
	async function executeCLICommand(command, args = []) {
		return new Promise((resolve, reject) => {
			const cliPath = path.join(__dirname, "..", "..", "bin", "speco-tasker.js");
			const nodeArgs = [cliPath, command, ...args];

			const child = spawn("node", nodeArgs, {
				cwd: testProjectDir,
				stdio: ["pipe", "pipe", "pipe"],
			});

			let stdout = "";
			let stderr = "";

			child.stdout.on("data", (data) => {
				stdout += data.toString();
			});

			child.stderr.on("data", (data) => {
				stderr += data.toString();
			});

			child.on("close", (code) => {
				resolve({ stdout, stderr, code });
			});

			child.on("error", (error) => {
				reject(error);
			});
		});
	}

	/**
	 * 模拟CLI命令执行（当前阶段使用）
	 * 当真实CLI命令实现后，这个函数将被替换为executeCLICommand
	 */
	async function mockExecuteCLICommand(command, args = []) {
		console.log(`🔧 Mock executing: speco-tasker ${command} ${args.join(" ")}`);

		// 模拟命令执行结果
		switch (command) {
			case "scan-ai":
				return {
					stdout: JSON.stringify({
						found: 4,
						files: [
							"src/ai-client.js",
							"src/chatgpt-integration.js",
							"docs/ai-setup.md",
							"src/utils/claude-helper.js"
						],
						patterns: ["openai", "claude", "chatgpt", "anthropic"],
					}),
					stderr: "",
					code: 0,
				};

			case "cleanup-ai":
				// 模拟清理AI内容
				await performMockAICleanup(args);
				return {
					stdout: JSON.stringify({
						success: true,
						filesProcessed: 4,
						filesRemoved: args.includes("--dry-run") ? 0 : 4,
						dryRun: args.includes("--dry-run"),
					}),
					stderr: "",
					code: 0,
				};

			case "verify-cleanup":
				return {
					stdout: JSON.stringify({
						clean: true,
						remainingAIContent: 0,
						totalFiles: 8,
						checkedFiles: 8,
					}),
					stderr: "",
					code: 0,
				};

			default:
				return {
					stdout: "",
					stderr: `Unknown command: ${command}`,
					code: 1,
				};
		}
	}

	/**
	 * 模拟AI清理操作（当真实服务实现后移除）
	 */
	async function performMockAICleanup(args) {
		const isDryRun = args.includes("--dry-run");

		if (!isDryRun) {
			// 模拟删除AI相关文件
			const aiFiles = [
				"src/ai-client.js",
				"src/chatgpt-integration.js",
				"docs/ai-setup.md",
				"src/utils/claude-helper.js"
			];

			for (const file of aiFiles) {
				const filePath = path.join(testProjectDir, file);
				if (fs.existsSync(filePath)) {
					// 实际删除文件
					fs.unlinkSync(filePath);
				}
			}
		}
	}

	describe("AI Content Detection Phase", () => {
		it("should detect AI content in project files using CLI command", async () => {
			// 当CLI命令实现后，替换为:
			// const result = await executeCLICommand("scan-ai");

			// 当前阶段使用模拟:
			const result = await mockExecuteCLICommand("scan-ai");

			expect(result.code).toBe(0);
			const scanResult = JSON.parse(result.stdout);
			expect(scanResult.found).toBeGreaterThan(0);
			expect(Array.isArray(scanResult.files)).toBe(true);
			expect(scanResult.files.length).toBeGreaterThan(0);
			expect(scanResult.patterns).toContain("openai");
			expect(scanResult.patterns).toContain("claude");
		});

		it("should have AI content files present before cleanup", () => {
			// Verify AI files exist
			expect(fs.existsSync(path.join(testProjectDir, "src/ai-client.js"))).toBe(true);
			expect(fs.existsSync(path.join(testProjectDir, "src/chatgpt-integration.js"))).toBe(true);
			expect(fs.existsSync(path.join(testProjectDir, "docs/ai-setup.md"))).toBe(true);
			expect(fs.existsSync(path.join(testProjectDir, "src/utils/claude-helper.js"))).toBe(true);
		});
	});

	describe("AI Content Cleanup Phase", () => {
		it("should perform dry-run cleanup using CLI command", async () => {
			// 当CLI命令实现后，替换为:
			// const result = await executeCLICommand("cleanup-ai", ["--dry-run"]);

			// 当前阶段使用模拟:
			const result = await mockExecuteCLICommand("cleanup-ai", ["--dry-run"]);

			expect(result.code).toBe(0);
			const cleanupResult = JSON.parse(result.stdout);
			expect(cleanupResult.success).toBe(true);
			expect(cleanupResult.dryRun).toBe(true);
			expect(cleanupResult.filesRemoved).toBe(0);
			expect(cleanupResult.filesProcessed).toBeGreaterThan(0);
		});

		it("should perform actual cleanup using CLI command", async () => {
			// 当CLI命令实现后，替换为:
			// const result = await executeCLICommand("cleanup-ai");

			// 当前阶段使用模拟:
			const result = await mockExecuteCLICommand("cleanup-ai");

			expect(result.code).toBe(0);
			const cleanupResult = JSON.parse(result.stdout);
			expect(cleanupResult.success).toBe(true);
			expect(cleanupResult.dryRun).toBe(false);
			expect(cleanupResult.filesRemoved).toBeGreaterThan(0);
		});

		it("should remove AI content files after cleanup", () => {
			// Verify AI files are removed
			expect(fs.existsSync(path.join(testProjectDir, "src/ai-client.js"))).toBe(false);
			expect(fs.existsSync(path.join(testProjectDir, "src/chatgpt-integration.js"))).toBe(false);
			expect(fs.existsSync(path.join(testProjectDir, "docs/ai-setup.md"))).toBe(false);
			expect(fs.existsSync(path.join(testProjectDir, "src/utils/claude-helper.js"))).toBe(false);
		});
	});

	describe("Cleanup Verification Phase", () => {
		it("should verify cleanup completion using CLI command", async () => {
			// 当CLI命令实现后，替换为:
			// const result = await executeCLICommand("verify-cleanup");

			// 当前阶段使用模拟:
			const result = await mockExecuteCLICommand("verify-cleanup");

			expect(result.code).toBe(0);
			const verification = JSON.parse(result.stdout);
			expect(verification.clean).toBe(true);
			expect(verification.remainingAIContent).toBe(0);
			expect(verification.checkedFiles).toBeGreaterThan(0);
		});

		it("should confirm no AI content remains in project", () => {
			// Check that no AI-related files remain
			const remainingFiles = fs.readdirSync(testProjectDir, { recursive: true })
				.filter(file => !file.includes("node_modules") && !file.includes(".git"))
				.filter(file => {
					try {
						const stats = fs.statSync(path.join(testProjectDir, file));
						// Only check regular files, not directories
						if (stats.isFile()) {
							const content = fs.readFileSync(path.join(testProjectDir, file), "utf8");
							return content.includes("openai") ||
								   content.includes("claude") ||
								   content.includes("chatgpt") ||
								   content.includes("anthropic");
						}
						return false;
					} catch {
						return false;
					}
				});	});

	describe("Complete AI Cleanup Workflow", () => {
		it("should complete full AI cleanup workflow from detection to verification", async () => {
			// 重新创建AI文件用于完整工作流测试
			createTestFilesWithAIContent();

			// 1. 检测阶段
			const scanResult = await mockExecuteCLICommand("scan-ai");
			expect(scanResult.code).toBe(0);

			// 2. 清理阶段
			const cleanupResult = await mockExecuteCLICommand("cleanup-ai");
			expect(cleanupResult.code).toBe(0);

			// 3. 验证阶段
			const verifyResult = await mockExecuteCLICommand("verify-cleanup");
			expect(verifyResult.code).toBe(0);

			const verification = JSON.parse(verifyResult.stdout);
			expect(verification.clean).toBe(true);

			console.log("✅ Complete AI cleanup workflow test passed");
		});

		it("should handle workflow errors gracefully", async () => {
			// Test error handling - invalid command
			const errorResult = await mockExecuteCLICommand("invalid-command");

			expect(errorResult.code).toBe(1);
			expect(errorResult.stderr).toContain("Unknown command");
		});
	});
});
