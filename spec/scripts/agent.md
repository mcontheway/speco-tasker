### 1. `common.sh` 脚本详情

这个脚本包含了一系列被其他脚本引用的通用函数和变量，旨在提供基础的 Git 和文件系统操作。

*   **脚本路径**: `spec/scripts/common.sh`
*   **主要功能**:
    *   **`get_repo_root()`**: 获取 Git 仓库的根目录路径。
    *   **`get_current_branch()`**: 获取当前所在的 Git 分支名称。
    *   **`check_feature_branch()`**: 检查当前分支是否符合特性分支的命名规范（例如 `001-feature-name`）。如果不符合，会输出错误信息并返回非零退出码。
    *   **`get_feature_dir()`**: 根据仓库根目录和分支名称，构建特性目录的路径（例如 `REPO_ROOT/specs/BRANCH_NAME`）。
    *   **`get_feature_paths()`**: 这是一个核心函数，它通过 `eval` 命令设置了一系列与当前特性分支相关的环境变量，包括：
        *   `REPO_ROOT` (仓库根目录)
        *   `CURRENT_BRANCH` (当前分支名)
        *   `FEATURE_DIR` (特性目录)
        *   `FEATURE_SPEC` (特性说明文件路径，`spec.md`)
        *   `IMPL_PLAN` (实现计划文件路径，`plan.md`)
        *   `TASKS` (任务文件路径，`tasks.md`)
        *   `RESEARCH` (研究文档路径，`research.md`)
        *   `DATA_MODEL` (数据模型文档路径，`data-model.md`)
        *   `QUICKSTART` (快速启动指南路径，`quickstart.md`)
        *   `CONTRACTS_DIR` (合同目录路径，`contracts/`)
    *   **`check_file()`**: 检查指定文件是否存在，并根据结果输出带有 `✓` 或 `✗` 标记的描述信息。
    *   **`check_dir()`**: 检查指定目录是否存在且不为空，并根据结果输出带有 `✓` 或 `✗` 标记的描述信息。
*   **使用方式**: 其他脚本通过 `source "$SCRIPT_DIR/common.sh"` 引入此脚本，然后可以直接调用其中定义的函数。
*   **设计目的**: 减少代码重复，确保所有特性相关的脚本都能以统一的方式获取和验证路径信息。

---

### 2. `check-task-prerequisites.sh` 脚本详情

这个脚本用于检查当前特性分支的实现计划和其他可选设计文档是否存在。

*   **脚本路径**: `spec/scripts/check-task-prerequisites.sh`
*   **主要功能**:
    *   **解析参数**: 支持 `--json` 参数，用于以 JSON 格式输出结果，方便程序化处理。
    *   **引入通用函数**: 引用 `common.sh` 来获取路径和检查文件。
    *   **获取特性路径**: 调用 `get_feature_paths` 函数设置所有特性相关的路径变量。
    *   **检查特性分支**: 验证当前 Git 分支是否符合特性分支的命名规范。
    *   **检查特性目录**: 确认 `FEATURE_DIR` 目录是否存在。如果不存在，会提示用户先运行 `/specify` 命令创建特性结构。
    *   **检查实现计划**: 强制性检查 `plan.md` (即 `IMPL_PLAN`) 文件是否存在。如果不存在，会提示用户先运行 `/plan` 命令创建计划。
    *   **列出可选设计文档**: 检查 `research.md`, `data-model.md`, `contracts/`, `quickstart.md` 等可选设计文档是否存在，并以 `✓` 或 `✗` 符号进行标记。
    *   **输出格式**:
        *   默认情况下，以人类可读的文本格式输出特性目录和可用文档列表。
        *   如果使用了 `--json` 模式，则以 JSON 格式输出 `FEATURE_DIR` 和一个包含所有存在的文档名称的 `AVAILABLE_DOCS` 数组。
*   **使用场景**: 在开始任务生成或进一步开发之前，确保所有必要的设计文档和实现计划都已就位。
*   **设计目的**: 确保在进行后续的 AI 任务生成等操作时，有足够的前置上下文和文档。即使某些可选文档缺失，脚本也会成功运行，以允许任务生成工作继续。

---

### 3. `create-new-feature.sh` 脚本详情

这个脚本用于创建一个新的特性分支、对应的特性目录结构，并从模板复制一个 `spec.md` 文件。

*   **脚本路径**: `spec/scripts/create-new-feature.sh`
*   **主要功能**:
    *   **解析参数**: 支持 `--json` 参数用于 JSON 格式输出，并接收一个特性描述作为强制参数。
    *   **生成特性编号**: 扫描 `specs` 目录，找出当前最高编号的特性目录，然后递增生成下一个三位数的特性编号（例如 `001`, `002`）。
    *   **规范化分支名称**: 将用户提供的特性描述转换为小写，替换特殊字符为连字符，并截取前 2-3 个有意义的词来构建分支名称，格式为 `XXX-meaningful-words`。
    *   **创建并切换分支**: 使用生成的 `BRANCH_NAME` 创建一个新的 Git 分支并立即切换到该分支。
    *   **创建特性目录**: 在 `SPECS_DIR` (即 `REPO_ROOT/specs/`) 下创建与新分支同名的特性目录（`FEATURE_DIR`）。
    *   **复制模板文件**: 尝试从 `REPO_ROOT/templates/spec-template.md` 复制一个模板文件到新创建的特性目录下的 `spec.md`。如果模板不存在，则创建一个空的 `spec.md`。
    *   **输出结果**:
        *   默认情况下，以 `KEY: VALUE` 格式输出 `BRANCH_NAME`, `SPEC_FILE`, `FEATURE_NUM`。
        *   如果使用了 `--json` 模式，则以 JSON 格式输出这些信息。
*   **使用场景**: 启动一个新的功能开发时，自动化创建分支和初始文档结构。
*   **设计目的**: 强制执行统一的特性分支命名规范和目录结构，确保项目的整洁性和可维护性，为后续的规划和文档工作打下基础。

---

### 4. `get-feature-paths.sh` 脚本详情

这个脚本的目的是获取当前特性分支的所有相关路径，但不会创建任何文件或目录。

*   **脚本路径**: `spec/scripts/get-feature-paths.sh`
*   **主要功能**:
    *   **引入通用函数**: 引用 `common.sh` 中的函数。
    *   **获取并设置路径**: 调用 `get_feature_paths` 函数，它会设置一系列环境变量（如 `REPO_ROOT`, `CURRENT_BRANCH`, `FEATURE_DIR`, `FEATURE_SPEC` 等）。
    *   **检查特性分支**: 验证当前 Git 分支是否符合特性分支的命名规范。
    *   **输出路径**: 以 `KEY: VALUE` 格式打印所有获取到的路径信息。
*   **使用场景**: 当其他脚本或工具需要知道当前特性分支的文件路径信息，但不希望修改文件系统时。例如，一个读取 `plan.md` 内容的脚本可能会先调用这个脚本来获取 `IMPL_PLAN` 的值。
*   **设计目的**: 提供一个只读的方式来获取特性分支相关的标准路径，避免不必要的副作用。

---

### 5. `setup-plan.sh` 脚本详情

这个脚本用于为当前特性分支设置实现计划结构。

*   **脚本路径**: `spec/scripts/setup-plan.sh`
*   **主要功能**:
    *   **解析参数**: 支持 `--json` 参数用于 JSON 格式输出。
    *   **引入通用函数**: 引用 `common.sh` 中的函数。
    *   **获取特性路径**: 调用 `get_feature_paths` 函数设置所有特性相关的路径变量。
    *   **检查特性分支**: 验证当前 Git 分支是否符合特性分支的命名规范。
    *   **创建特性目录**: 确保 `FEATURE_DIR` 目录存在，如果不存在则创建。
    *   **复制计划模板**: 尝试从 `REPO_ROOT/templates/plan-template.md` 复制一个模板文件到 `IMPL_PLAN` (即 `plan.md`)。
    *   **输出结果**:
        *   默认情况下，以 `KEY: VALUE` 格式输出 `FEATURE_SPEC`, `IMPL_PLAN`, `SPECS_DIR`, `BRANCH`。
        *   如果使用了 `--json` 模式，则以 JSON 格式输出这些信息。
*   **使用场景**: 在特性说明（`spec.md`）完成后，开始制定详细的实现计划时使用。
*   **设计目的**: 为 AI 生成实现计划或人工编写计划提供一个标准化的模板文件和存放位置，确保规划文档的一致性。

---

### 6. `update-agent-context.sh` 脚本详情

这个脚本用于根据最新的特性实现计划（`plan.md`）增量更新 AI 代理的上下文文件，包括 `CLAUDE.md`, `GEMINI.md`, 和 `.github/copilot-instructions.md`。

*   **脚本路径**: `spec/scripts/update-agent-context.sh`
*   **主要功能**:
    *   **获取路径**: 确定仓库根目录、当前分支和新计划文件的路径。
    *   **验证计划文件**: 检查 `plan.md` 是否存在，如果不存在则报错退出。
    *   **提取技术栈信息**: 从 `plan.md` 中解析出语言、框架、测试方法、存储方案和项目类型等关键技术信息。
    *   **`update_agent_file()` 函数**: 这是一个核心辅助函数，负责处理单个代理上下文文件的更新逻辑：
        *   **文件不存在时创建**: 如果目标代理文件不存在，则根据 `agent-file-template.md` 模板创建新文件，并用提取到的技术信息填充占位符，例如项目名称、日期、激活技术、项目结构、常用命令和最近更改等。
        *   **文件存在时更新**: 如果目标代理文件已存在，则以增量方式更新内容。它会解析现有文件的特定部分（例如 `## Active Technologies`, `## Project Structure`, `## Commands`, `## Recent Changes`），添加新的技术信息，更新项目结构（例如如果项目类型是 `web` 且 `frontend/` 结构未添加），添加新语言的命令，并更新最近更改列表（只保留最新的 3 条）。
        *   **保留手动添加内容**: 该函数会尝试识别文件中的 `<!-- MANUAL ADDITIONS START -->` 和 `<!-- MANUAL ADDITIONS END -->` 标记，并在更新过程中保留用户手动添加的内容。
    *   **文件选择与更新**:
        *   如果调用时提供了参数（例如 `claude`, `gemini`, `copilot`），则只更新指定类型的代理文件。
        *   如果没有提供参数，则会遍历所有已存在的代理文件 (`CLAUDE.md`, `GEMINI.md`, `COPILOT_FILE`) 进行更新。如果没有任何代理文件存在，则默认创建一个 `CLAUDE.md` 文件。
    *   **更新总结**: 脚本最后会输出一个更新摘要，列出添加的语言、框架和数据库信息。
*   **使用场景**: 每次完成一个特性的实现计划（`plan.md`）后，运行此脚本可以自动更新 AI 助手对当前项目技术栈和项目背景的理解，使其在后续的交互中能够提供更准确和相关的建议。
*   **设计目的**: 保持 AI 助手的知识库与项目实际进展同步，减少 AI 在开发过程中的“上下文缺失”问题，提高其协助效率。它通过自动化的方式，确保 AI 始终拥有最新、最相关的项目背景信息。

